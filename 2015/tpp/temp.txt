A) заметим, что просят вывести три натуральных числа, а не "числа больше 1". Иначе наш код за разумное время не ответит на тест вида "простое число порядка 10**60 в кубе"
В) в общем-то можно немного упростить код с разбора, заметив, что "только с одного конца" это логический ксор, тогда перепутать and и or и -4 +4 будет невозможно. Да и синтаксис [::-1][:4] можно заменить на более понятные [:-4]. Если писать не на питоне, удобнее использовать java и endsWith с startsWith или просто сравнивать подстроки.
С) В общем-то можно написать так, как в разборе, а можно использовать регулярки и заметить, что наш пароль должен удовлетворять четырем регуляркам(ну и длина, разумеется): /^([0-9]|[a-z]|[A-Z])*$/ /[0-9]/ /[a-z]/ /[A-Z]/, поэтому для такой задачи лучше использовать perl(не помню был там он или нет. Хотя наверно нет, потому что я написал на питоне)
Д) Ну, мой код такой же, как и в разборе, только чуть понятнее(опять же на мой взгляд) из-за коротких имен переменных. Просто внимательно читаем условие(не забывая про взятие адреса по модулю и 0 - 1 == 0 при вычитании из ячейки).
Е) Описано в самом начале
Ф) Заметим, что в пароле используются только буквы верхнего ряда клавиатуры, т.е только 10 букв. Длина пароля не более 7 символов, значит паролей 10^7. Для каждого пароля вычислим его хэш за длину и проверим, совпал ли. Итого решение за О(n*c^n). Непонятно, зачем нужен был второй модуль, кроме того, чтобы запутать участников, потому что при использовании 64битного типа все вычисления в него помещались.
Перед вычислением хэшей нужно запомнить степени р1, иначе будет слишком много ненужных умножений и наше решение не уложится в ограничения по времени. Для перебора паролей я использовал биекцию из qwertyuiop <=> 0123456789, поэтому перебор пароля -- перебор числа от 0 до 10^n

От программы на БФ совершенно непонятно как ее решать. Поэтому напишу свои мысли как я решал:
В интерпретатор очень просто допилить визуализатор. Достаточно после каждого действия выводить кусочек ленты с курсором.
Ж1) Будем уменьшать первое число, пока оно не станет нулем. Ровно столько раз надо увеличить второе. поэтому получается такой код: while(a[i] != 0) a[i]--, a[i+1]++
Ж2) Алгоритм такой: будем хранить подряд "результат, следующее число". Тогда для обработки следующего числа достаточно перемножить текущие ячейки и перейти к следующим. Изначально результат равен нейтральному элементу по умножению, то есть 1
Ж3) Сначала считаем все числа. Это можно сделать как в примере к Д. Теперь просто пойдем обратно и будем выводить числа. Заметим, что на не нужно переворачивать последовательность в памяти, можно ее просто вывести.
Ж4) Делается так же, как и сложение. Только вместо прибавления следующей ячейки, перемножаем две следующие
Ж5) Считаем все числа. Пойдем в обратном порядке, и будем вычитать из каждого 1. Если получилось больше 0, значит запомним индекс данной ячейки в регистр. Так как идем в обратном порядке, мы найдем как раз первое число, отличное от 1
Ж6) На мой взгляд самая сложная задача. Я решал ее так(код опитонен, поэтому из него что-то можно понять)
будем хранить в памяти так:
результат, служебная ячейка, служебная ячейка2, служебная ячейка3, последовательность.
пусть наша последовательность будет 2 3 2 1
тогда изначально у нас будет записано 1 0 0 0 2 3 3 1
пойдем до упора вправо, скопируем последнее число в начало, сравним с первым. сравнивать будем как "если числа а и б равны, то (а-б) + б-а == 0
итого 
1 2 1 1 2 3 2 0
1 0 1 0 0 3 2 0
0 0 0 0 0 3 2 0
Если запустить мой интерпретатор, получится так: http://pastebin.com/G7W4Exy4
Ж7) 80 = 5*2^4. Далее запишем числа как
80 xxx     fib[i + 1] fib[i]
79 fib[i]  fib[i + 1] fib[i]
79 fib[i]  fib[i + 1] fib[i + 1]
79 0       fib[i + 2] fib[i + 1]
дальше понятно.
Ж8) Будем сортировать подсчетом. Сначала заполним все ячейчки (которые нам нужны, или совсем все) единицами. Теперь будем читать числа по очереди и двигать его вправа вычитая 1, до самого конца. Если в текущий момент число больше 0, прибавим к текущей ячейке 1. После того как мы считаем все числа, у нас в и-той позиции будет хранить количество чисел больших или равных и. Понятно, что количество числа и теперь просто посчитать. Столько чисел и выведем. Эмуляция алгоритма здесь:
http://pastebin.com/8zTpApdN 
